/* The bootloader will look at this image and start execution at the symbol
   designated at the entry point. */
ENTRY(_start)

/* Tell where the various sections of the object files will be put in the final
   kernel image. */
SECTIONS
{
	/* Begin putting sections at 1 MiB, a conventional place for kernels to be
	   loaded at by the bootloader. */
	. = 1M;

	/* First put the multiboot header*/
        .init :
        {
		*(.multiboot)
                KEEP (*(SORT_NONE(.init)))
        }
        .fini :
        {
                KEEP (*(SORT_NONE(.fini)))
        }
	.text BLOCK(4K) : ALIGN(4K)
	{
                *(.text.unlikely .text.*_unlikely .text.unlikely.*)
                *(.text.exit .text.exit.*)
                *(.text.startup .text.startup.*)
                *(.text.hot .text.hot.*)
                *(.text .stub .text.* .gnu.linkonce.t.*)
                . = ALIGN(4K);
                *(.bootstrap) /* bootstrap must be the sole thing in a page. */
                . = ALIGN(4K);
	}

	/* Read-only data. */
	.rodata BLOCK(4K) : ALIGN(4K)
	{
		*(.rodata .rodata.* .gnu.linkonce.r.*)
                *(.rodata1)
	}
        .eh_frame_hdr : { *(.eh_frame_hdr) }
        .eh_frame : ONLY_IF_RO { KEEP (*(.eh_frame)) }
        .gcc_except_table : ONLY_IF_RO { *(.gcc_except_table
        .gcc_except_table.*) }
        /* These sections are generated by the Sun/Oracle C++ compiler.  */
        .exception_ranges   : ONLY_IF_RO { *(.exception_ranges
        .exception_ranges*) }

        . = ALIGN(4K);

	/* Read-write data (initialized) */
        /* Exception handling  */
        .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }
        .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
        .exception_ranges   : ONLY_IF_RW { *(.exception_ranges .exception_ranges*) }
        /* Thread Local Storage sections  */
        .tdata	  : { *(.tdata .tdata.* .gnu.linkonce.td.*) }
        .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
        .preinit_array     :
        {
          PROVIDE_HIDDEN (__preinit_array_start = .);
          KEEP (*(.preinit_array))
          PROVIDE_HIDDEN (__preinit_array_end = .);
         }
         .init_array     :
         {
           PROVIDE_HIDDEN (__init_array_start = .);
           KEEP (*(SORT(.init_array.*)))
           KEEP (*(.init_array ))
           PROVIDE_HIDDEN (__init_array_end = .);
         }
         .fini_array     :
         {
           PROVIDE_HIDDEN (__fini_array_start = .);
           KEEP (*(SORT(.fini_array.*)))
           KEEP (*(.fini_array ))
           PROVIDE_HIDDEN (__fini_array_end = .);
         }
         .ctors          :
         {
           /* gcc uses crtbegin.o to find the start of
              the constructors, so we make sure it is
              first.  Because this is a wildcard, it
              doesn't matter if the user does not
              actually link against crtbegin.o; the
              linker won't look for a file to match a
              wildcard.  The wildcard also means that it
              doesn't matter which directory crtbegin.o
              is in.  */
           KEEP (*crtbegin.o(.ctors))
           KEEP (*crtbegin?.o(.ctors))
           /* We don't want to include the .ctor section from
              the crtend.o file until after the sorted ctors.
              The .ctor section from the crtend file contains the
              end of ctors marker and it must be last */
           KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
           KEEP (*(SORT(.ctors.*)))
           KEEP (*(.ctors))
         }
         .dtors          :
         {
           KEEP (*crtbegin.o(.dtors))
           KEEP (*crtbegin?.o(.dtors))
           KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
           KEEP (*(SORT(.dtors.*)))
           KEEP (*(.dtors))
         }
         .jcr            : { KEEP (*(.jcr)) }
         .dynamic        : { *(.dynamic) }
         .got            : { *(.got) *(.igot) }
         //. = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 12 ? 12 : 0, .);
         .got.plt        : { *(.got.plt)  *(.igot.plt) }
         .data           :
         {
           *(.data .data.* .gnu.linkonce.d.*)
           SORT(CONSTRUCTORS)
         }
         .data1          : { *(.data1) }

	/* Read-write data (uninitialized) and stack */
        .bss            :
        {
          *(.dynbss)
          *(.bss .bss.* .gnu.linkonce.b.*)
          *(COMMON)
          *(.bootstrap_stack)
          /* Align here to ensure that the .bss section occupies space up to
             _end.  Align after .bss to ensure correct alignment even if the
             .bss section disappears because there are no input sections.
             FIXME: Why do we need it? When there is no .bss section, we don't
             pad the .data section.  */
          . = ALIGN(. != 0 ? 32 / 8 : 1);
        }
        . = ALIGN(32 / 8);
        . = SEGMENT_START("ldata-segment", .);
        . = ALIGN(32 / 8);
	
	/* The compiler may produce other sections, put them in the proper place in
	   in this file, if you'd like to include them in the final kernel. */
}
